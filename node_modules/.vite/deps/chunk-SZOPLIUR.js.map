{
  "version": 3,
  "sources": ["../../@turf/collect/node_modules/quickselect/quickselect.js", "../../@turf/collect/node_modules/rbush/index.js", "../../@turf/meta/dist/es/index.js", "../../@turf/helpers/dist/es/index.js", "../../@turf/bbox/dist/es/index.js", "../../@turf/invariant/dist/es/index.js", "../../@turf/boolean-point-in-polygon/dist/es/index.js", "../../@turf/collect/dist/es/index.js"],
  "sourcesContent": ["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n", "'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n", "import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n", "/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n", "import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n", "import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n", "import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n", "import turfbbox from \"@turf/bbox\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport rbush from \"rbush\";\n/**\n * Merges a specified property from a FeatureCollection of points into a\n * FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty`\n * for polygons, this finds every point that lies within each polygon, collects the\n * `inProperty` values from those points, and adds them as an array to `outProperty`\n * on the polygon.\n *\n * @name collect\n * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate\n * @param {FeatureCollection<Point>} points points to be aggregated\n * @param {string} inProperty property to be nested from\n * @param {string} outProperty property to be nested into\n * @returns {FeatureCollection<Polygon>} polygons with properties listed based on `outField`\n * @example\n * var poly1 = turf.polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);\n * var poly2 = turf.polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);\n * var polyFC = turf.featureCollection([poly1, poly2]);\n * var pt1 = turf.point([5,5], {population: 200});\n * var pt2 = turf.point([1,3], {population: 600});\n * var pt3 = turf.point([14,2], {population: 100});\n * var pt4 = turf.point([13,1], {population: 200});\n * var pt5 = turf.point([19,7], {population: 300});\n * var pointFC = turf.featureCollection([pt1, pt2, pt3, pt4, pt5]);\n * var collected = turf.collect(polyFC, pointFC, 'population', 'values');\n * var values = collected.features[0].properties.values\n * //=values => [200, 600]\n *\n * //addToMap\n * var addToMap = [pointFC, collected]\n */\nfunction collect(polygons, points, inProperty, outProperty) {\n    var rtree = rbush(6);\n    var treeItems = points.features.map(function (item) {\n        var _a;\n        return {\n            minX: item.geometry.coordinates[0],\n            minY: item.geometry.coordinates[1],\n            maxX: item.geometry.coordinates[0],\n            maxY: item.geometry.coordinates[1],\n            property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty],\n        };\n    });\n    rtree.load(treeItems);\n    polygons.features.forEach(function (poly) {\n        if (!poly.properties) {\n            poly.properties = {};\n        }\n        var bbox = turfbbox(poly);\n        var potentialPoints = rtree.search({\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3],\n        });\n        var values = [];\n        potentialPoints.forEach(function (pt) {\n            if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {\n                values.push(pt.property);\n            }\n        });\n        poly.properties[outProperty] = values;\n    });\n    return polygons;\n}\nexport default collect;\n"],
  "mappings": "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",
  "names": ["rbush", "bbox", "es_exports", "bbox", "geometry", "bbox", "feature", "es_exports", "feature", "featureCollection", "point", "polygon", "bbox", "polygons", "points", "rbush", "bbox", "es_default"]
}
