import {
  __commonJS,
  __require
} from "./chunk-62VDRKYJ.js";

// node_modules/togpx/togpx.js
var require_togpx = __commonJS({
  "node_modules/togpx/togpx.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.togpx = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function e(t, n, r) {
        function s(o3, u) {
          if (!n[o3]) {
            if (!t[o3]) {
              var a = typeof __require == "function" && __require;
              if (!u && a)
                return a(o3, true);
              if (i)
                return i(o3, true);
              var f = new Error("Cannot find module '" + o3 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o3] = { exports: {} };
            t[o3][0].call(l.exports, function(e2) {
              var n2 = t[o3][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o3].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o2 = 0; o2 < r.length; o2++)
          s(r[o2]);
        return s;
      }({ 1: [function(require2, module3, exports3) {
        var JXON = require2("jxon");
        JXON.config({ attrPrefix: "@" });
        function togpx(geojson, options) {
          options = function(defaults, options2) {
            for (var k in defaults) {
              if (options2.hasOwnProperty(k))
                defaults[k] = options2[k];
            }
            return defaults;
          }({
            creator: "togpx",
            metadata: void 0,
            featureTitle: get_feature_title,
            featureDescription: get_feature_description,
            featureLink: void 0,
            featureCoordTimes: get_feature_coord_times
          }, options || {});
          if (typeof options.featureCoordTimes === "string") {
            var customTimesFieldKey = options.featureCoordTimes;
            options.featureCoordTimes = function(feature) {
              return feature.properties[customTimesFieldKey];
            };
          }
          function get_feature_title(props) {
            if (!props)
              return "";
            if (typeof props.tags === "object") {
              var tags_title = get_feature_title(props.tags);
              if (tags_title !== "")
                return tags_title;
            }
            if (props.name)
              return props.name;
            if (props.ref)
              return props.ref;
            if (props.id)
              return props.id;
            return "";
          }
          function get_feature_description(props) {
            if (!props)
              return "";
            if (typeof props.tags === "object")
              return get_feature_description(props.tags);
            var res = "";
            for (var k in props) {
              if (typeof props[k] === "object")
                continue;
              res += k + "=" + props[k] + "\n";
            }
            return res.substr(0, res.length - 1);
          }
          function get_feature_coord_times(feature) {
            if (!feature.properties)
              return null;
            return feature.properties.times || feature.properties.coordTimes || null;
          }
          function add_feature_link(o2, f) {
            if (options.featureLink)
              o2.link = { "@href": options.featureLink(f.properties) };
          }
          var gpx = { "gpx": {
            "@xmlns": "http://www.topografix.com/GPX/1/1",
            "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
            "@xsi:schemaLocation": "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd",
            "@version": "1.1",
            "metadata": null,
            "wpt": [],
            "trk": []
          } };
          if (options.creator)
            gpx.gpx["@creator"] = options.creator;
          if (options.metadata)
            gpx.gpx["metadata"] = options.metadata;
          else
            delete options.metadata;
          var features;
          if (geojson.type === "FeatureCollection")
            features = geojson.features;
          else if (geojson.type === "Feature")
            features = [geojson];
          else
            features = [{ type: "Feature", properties: {}, geometry: geojson }];
          features.forEach(function mapFeature(f) {
            switch (f.geometry.type) {
              case "Point":
              case "MultiPoint":
                var coords = f.geometry.coordinates;
                if (f.geometry.type == "Point")
                  coords = [coords];
                coords.forEach(function(coordinates) {
                  o = {
                    "@lat": coordinates[1],
                    "@lon": coordinates[0],
                    "name": options.featureTitle(f.properties),
                    "desc": options.featureDescription(f.properties)
                  };
                  if (coordinates[2] !== void 0) {
                    o.ele = coordinates[2];
                  }
                  add_feature_link(o, f);
                  gpx.gpx.wpt.push(o);
                });
                break;
              case "LineString":
              case "MultiLineString":
                var coords = f.geometry.coordinates;
                var times = options.featureCoordTimes(f);
                if (f.geometry.type == "LineString")
                  coords = [coords];
                o = {
                  "name": options.featureTitle(f.properties),
                  "desc": options.featureDescription(f.properties)
                };
                add_feature_link(o, f);
                o.trkseg = [];
                coords.forEach(function(coordinates) {
                  var seg = { trkpt: [] };
                  coordinates.forEach(function(c, i) {
                    var o2 = {
                      "@lat": c[1],
                      "@lon": c[0]
                    };
                    if (c[2] !== void 0) {
                      o2.ele = c[2];
                    }
                    if (times && times[i]) {
                      o2.time = times[i];
                    }
                    seg.trkpt.push(o2);
                  });
                  o.trkseg.push(seg);
                });
                gpx.gpx.trk.push(o);
                break;
              case "Polygon":
              case "MultiPolygon":
                o = {
                  "name": options.featureTitle(f.properties),
                  "desc": options.featureDescription(f.properties)
                };
                add_feature_link(o, f);
                o.trkseg = [];
                var coords = f.geometry.coordinates;
                var times = options.featureCoordTimes(f);
                if (f.geometry.type == "Polygon")
                  coords = [coords];
                coords.forEach(function(poly) {
                  poly.forEach(function(ring) {
                    var seg = { trkpt: [] };
                    var i = 0;
                    ring.forEach(function(c) {
                      var o2 = {
                        "@lat": c[1],
                        "@lon": c[0]
                      };
                      if (c[2] !== void 0) {
                        o2.ele = c[2];
                      }
                      if (times && times[i]) {
                        o2.time = times[i];
                      }
                      i++;
                      seg.trkpt.push(o2);
                    });
                    o.trkseg.push(seg);
                  });
                });
                gpx.gpx.trk.push(o);
                break;
              case "GeometryCollection":
                f.geometry.geometries.forEach(function(geometry) {
                  var pseudo_feature = {
                    "properties": f.properties,
                    "geometry": geometry
                  };
                  mapFeature(pseudo_feature);
                });
                break;
              default:
                console.log("warning: unsupported geometry type: " + f.geometry.type);
            }
          });
          gpx_str = JXON.stringify(gpx);
          return gpx_str;
        }
        ;
        module3.exports = togpx;
      }, { "jxon": 2 }], 2: [function(require2, module3, exports3) {
        (function(root, factory) {
          if (typeof define2 === "function" && define2.amd) {
            define2([], factory(window));
          } else if (typeof exports3 === "object") {
            if (typeof window === "object" && window.DOMImplementation && window.XMLSerializer && window.DOMParser) {
              module3.exports = factory(window);
            } else {
              module3.exports = factory(require2("xmldom"), true);
            }
          } else {
            root.JXON = factory(window);
          }
        })(
          this,
          function(xmlDom, isNodeJs) {
            var opts = {
              valueKey: "_",
              attrKey: "$",
              attrPrefix: "$",
              lowerCaseTags: false,
              trueIsEmpty: false,
              autoDate: false,
              ignorePrefixedNodes: false,
              parseValues: false
            };
            var aCache = [];
            var rIsNull = /^\s*$/;
            var rIsBool = /^(?:true|false)$/i;
            var DOMParser;
            return new function() {
              this.config = function(cfg) {
                for (var k in cfg) {
                  opts[k] = cfg[k];
                }
                if (opts.parserErrorHandler) {
                  DOMParser = new xmlDom.DOMParser({
                    errorHandler: opts.parserErrorHandler,
                    locator: {}
                  });
                }
              };
              function parseText(sValue) {
                if (!opts.parseValues) {
                  return sValue;
                }
                if (rIsNull.test(sValue)) {
                  return null;
                }
                if (rIsBool.test(sValue)) {
                  return sValue.toLowerCase() === "true";
                }
                if (isFinite(sValue)) {
                  return parseFloat(sValue);
                }
                if (opts.autoDate && isFinite(Date.parse(sValue))) {
                  return new Date(sValue);
                }
                return sValue;
              }
              function EmptyTree() {
              }
              EmptyTree.prototype.toString = function() {
                return "null";
              };
              EmptyTree.prototype.valueOf = function() {
                return null;
              };
              function objectify(vValue) {
                return vValue === null ? new EmptyTree() : vValue instanceof Object ? vValue : new vValue.constructor(vValue);
              }
              function createObjTree(oParentNode, nVerb, bFreeze, bNesteAttr) {
                var CDATA = 4, TEXT = 3, ELEMENT = 1, nLevelStart = aCache.length, bChildren = oParentNode.hasChildNodes(), bAttributes = oParentNode.nodeType === oParentNode.ELEMENT_NODE && oParentNode.hasAttributes(), bHighVerb = Boolean(nVerb & 2), nLength = 0, sCollectedTxt = "", vResult = bHighVerb ? {} : opts.trueIsEmpty ? true : "", sProp, vContent;
                if (bChildren) {
                  for (var oNode, nItem = 0; nItem < oParentNode.childNodes.length; nItem++) {
                    oNode = oParentNode.childNodes.item(nItem);
                    if (oNode.nodeType === CDATA) {
                      sCollectedTxt += oNode.nodeValue;
                    } else if (oNode.nodeType === TEXT) {
                      sCollectedTxt += oNode.nodeValue.trim();
                    } else if (oNode.nodeType === ELEMENT && !(opts.ignorePrefixedNodes && oNode.prefix)) {
                      aCache.push(oNode);
                    }
                  }
                }
                var nLevelEnd = aCache.length, vBuiltVal = parseText(sCollectedTxt);
                if (!bHighVerb && (bChildren || bAttributes)) {
                  vResult = nVerb === 0 ? objectify(vBuiltVal) : {};
                }
                for (var nElId = nLevelStart; nElId < nLevelEnd; nElId++) {
                  sProp = aCache[nElId].nodeName;
                  if (opts.lowerCaseTags) {
                    sProp = sProp.toLowerCase();
                  }
                  vContent = createObjTree(aCache[nElId], nVerb, bFreeze, bNesteAttr);
                  if (vResult.hasOwnProperty(sProp)) {
                    if (vResult[sProp].constructor !== Array) {
                      vResult[sProp] = [vResult[sProp]];
                    }
                    vResult[sProp].push(vContent);
                  } else {
                    vResult[sProp] = vContent;
                    nLength++;
                  }
                }
                if (bAttributes) {
                  var nAttrLen = oParentNode.attributes.length, sAPrefix = bNesteAttr ? "" : opts.attrPrefix, oAttrParent = bNesteAttr ? {} : vResult;
                  for (var oAttrib, oAttribName, nAttrib = 0; nAttrib < nAttrLen; nLength++, nAttrib++) {
                    oAttrib = oParentNode.attributes.item(nAttrib);
                    oAttribName = oAttrib.name;
                    if (opts.lowerCaseTags) {
                      oAttribName = oAttribName.toLowerCase();
                    }
                    oAttrParent[sAPrefix + oAttribName] = parseText(oAttrib.value.trim());
                  }
                  if (bNesteAttr) {
                    if (bFreeze) {
                      Object.freeze(oAttrParent);
                    }
                    vResult[opts.attrKey] = oAttrParent;
                    nLength -= nAttrLen - 1;
                  }
                }
                if (nVerb === 3 || (nVerb === 2 || nVerb === 1 && nLength > 0) && sCollectedTxt) {
                  vResult[opts.valueKey] = vBuiltVal;
                } else if (!bHighVerb && nLength === 0 && sCollectedTxt) {
                  vResult = vBuiltVal;
                }
                if (bFreeze && (bHighVerb || nLength > 0)) {
                  Object.freeze(vResult);
                }
                aCache.length = nLevelStart;
                return vResult;
              }
              function loadObjTree(oXMLDoc, oParentEl, oParentObj) {
                var vValue, oChild, elementNS;
                if (oParentObj.constructor === String || oParentObj.constructor === Number || oParentObj.constructor === Boolean) {
                  oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toString()));
                  if (oParentObj === oParentObj.valueOf()) {
                    return;
                  }
                } else if (oParentObj.constructor === Date) {
                  oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toISOString()));
                }
                for (var sName in oParentObj) {
                  vValue = oParentObj[sName];
                  if (vValue === void 0) {
                    continue;
                  }
                  if (vValue === null) {
                    vValue = {};
                  }
                  if (isFinite(sName) || vValue instanceof Function) {
                    continue;
                  }
                  if (sName === opts.valueKey) {
                    if (vValue !== null && vValue !== true) {
                      oParentEl.appendChild(oXMLDoc.createTextNode(vValue.constructor === Date ? vValue.toISOString() : String(vValue)));
                    }
                  } else if (sName === opts.attrKey) {
                    for (var sAttrib in vValue) {
                      oParentEl.setAttribute(sAttrib, vValue[sAttrib]);
                    }
                  } else if (sName === opts.attrPrefix + "xmlns") {
                    if (isNodeJs) {
                      oParentEl.setAttribute(sName.slice(1), vValue);
                    }
                  } else if (sName.charAt(0) === opts.attrPrefix) {
                    oParentEl.setAttribute(sName.slice(1), vValue);
                  } else if (vValue.constructor === Array) {
                    for (var nItem in vValue) {
                      if (!vValue.hasOwnProperty(nItem))
                        continue;
                      elementNS = vValue[nItem] && vValue[nItem][opts.attrPrefix + "xmlns"] || oParentEl.namespaceURI;
                      if (elementNS) {
                        oChild = oXMLDoc.createElementNS(elementNS, sName);
                      } else {
                        oChild = oXMLDoc.createElement(sName);
                      }
                      loadObjTree(oXMLDoc, oChild, vValue[nItem] || {});
                      oParentEl.appendChild(oChild);
                    }
                  } else {
                    elementNS = (vValue || {})[opts.attrPrefix + "xmlns"] || oParentEl.namespaceURI;
                    if (elementNS) {
                      oChild = oXMLDoc.createElementNS(elementNS, sName);
                    } else {
                      oChild = oXMLDoc.createElement(sName);
                    }
                    if (vValue instanceof Object) {
                      loadObjTree(oXMLDoc, oChild, vValue);
                    } else if (vValue !== null && (vValue !== true || !opts.trueIsEmpty)) {
                      oChild.appendChild(oXMLDoc.createTextNode(vValue.toString()));
                    }
                    oParentEl.appendChild(oChild);
                  }
                }
              }
              this.xmlToJs = this.build = function(oXMLParent, nVerbosity, bFreeze, bNesteAttributes) {
                var _nVerb = arguments.length > 1 && typeof nVerbosity === "number" ? nVerbosity & 3 : 1;
                return createObjTree(oXMLParent, _nVerb, bFreeze || false, arguments.length > 3 ? bNesteAttributes : _nVerb === 3);
              };
              this.jsToXml = this.unbuild = function(oObjTree, sNamespaceURI, sQualifiedName, oDocumentType) {
                var documentImplementation = xmlDom.document && xmlDom.document.implementation || new xmlDom.DOMImplementation();
                var oNewDoc = documentImplementation.createDocument(sNamespaceURI || null, sQualifiedName || "", oDocumentType || null);
                loadObjTree(oNewDoc, oNewDoc.documentElement || oNewDoc, oObjTree);
                return oNewDoc;
              };
              this.stringToXml = function(xmlStr) {
                if (!DOMParser) {
                  DOMParser = new xmlDom.DOMParser();
                }
                return DOMParser.parseFromString(xmlStr, "application/xml");
              };
              this.xmlToString = function(xmlObj) {
                if (typeof xmlObj.xml !== "undefined") {
                  return xmlObj.xml;
                } else {
                  return new xmlDom.XMLSerializer().serializeToString(xmlObj);
                }
              };
              this.stringToJs = function(str) {
                var xmlObj = this.stringToXml(str);
                return this.xmlToJs(xmlObj);
              };
              this.jsToString = this.stringify = function(oObjTree, sNamespaceURI, sQualifiedName, oDocumentType) {
                return this.xmlToString(
                  this.jsToXml(oObjTree, sNamespaceURI, sQualifiedName, oDocumentType)
                );
              };
              this.each = function(arr, func, thisArg) {
                if (arr instanceof Array) {
                  arr.forEach(func, thisArg);
                } else {
                  [arr].forEach(func, thisArg);
                }
              };
            }();
          }
        );
      }, { "xmldom": 3 }], 3: [function(require2, module3, exports3) {
      }, {}] }, {}, [1])(1);
    });
  }
});
export default require_togpx();
//# sourceMappingURL=togpx_togpx__js.js.map
