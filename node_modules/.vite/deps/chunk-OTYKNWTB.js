import {
  getForProjection,
  wrapX
} from "./chunk-TEHJRZNC.js";
import {
  TileCache_default
} from "./chunk-A36ARYHR.js";
import {
  Source_default
} from "./chunk-N4W7YRGW.js";
import {
  getKeyZXY,
  withinExtentAndZ
} from "./chunk-TMQXW2RQ.js";
import {
  TileState_default
} from "./chunk-F5472VLO.js";
import {
  scale,
  toSize
} from "./chunk-5JVGRBF3.js";
import {
  Event_default,
  abstract
} from "./chunk-7OVONZTQ.js";
import {
  assert
} from "./chunk-QFCIXVZ3.js";
import {
  equivalent
} from "./chunk-CS3SV3WY.js";

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  TILELOADSTART: "tileloadstart",
  TILELOADEND: "tileloadend",
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/source/Tile.js
var TileSource = class extends Source_default {
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tileCache = new TileCache_default(options.cacheSize || 0);
    this.tmpSize = [0, 0];
    this.key_ = options.key || "";
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    let covered = true;
    let tile, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = getKeyZXY(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = tileCache.get(tileCoordKey);
          loaded = tile.getState() === TileState_default.LOADED;
          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  getGutterForProjection(projection) {
    return 0;
  }
  getKey() {
    return this.key_;
  }
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  getOpaque(projection) {
    return this.opaque_;
  }
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  getTileGrid() {
    return this.tileGrid;
  }
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    assert(
      sourceProjection === null || equivalent(sourceProjection, projection),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    );
    return this.tileCache;
  }
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale(tileSize, tilePixelRatio, this.tmpSize);
  }
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear();
    super.refresh();
  }
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }
  useTile(z, x, y, projection) {
  }
};
var TileSourceEvent = class extends Event_default {
  constructor(type, tile) {
    super(type);
    this.tile = tile;
  }
};
var Tile_default = TileSource;

export {
  TileEventType_default,
  TileSourceEvent,
  Tile_default
};
//# sourceMappingURL=chunk-OTYKNWTB.js.map
